# ğŸš€ ì¶”ê°€ ê°œì„  ì œì•ˆ ë° AIì˜ ìƒê°

## ğŸ†• ìµœì‹  ê°œì„  ì œì•ˆ (2025-08-15 23:40)

### ğŸ¯ AIì˜ ì„ì˜íŒë‹¨ ë‚´ìš© ë° ìƒê° (ì—…ë°ì´íŠ¸)

#### ğŸ” í˜„ì¬ í”„ë¡œì íŠ¸ ìƒí™© ë¶„ì„ (ì‹¬í™”)
í”„ë¡œì íŠ¸ë¥¼ ë” ê¹Šì´ ë¶„ì„í•œ ê²°ê³¼, ë‹¤ìŒê³¼ ê°™ì€ ì¶”ê°€ì ì¸ ì¸ì‚¬ì´íŠ¸ë¥¼ ì–»ì—ˆìŠµë‹ˆë‹¤:

1. **í…ŒíŠ¸ë¦­ìŠ¤ ê²Œì„**: v0.2.1ë¡œ ê²Œì„ ê°œì„  ë° ê¸°ëŠ¥ ì¶”ê°€ ì™„ë£Œ
   - **ê°•ì **: ëª¨ë°”ì¼ í„°ì¹˜ ì§€ì›, ì½¤ë³´ ì‹œìŠ¤í…œ, ìµœê³  ì ìˆ˜ ì €ì¥
   - **ê°œì„  í•„ìš”**: ì‚¬ìš´ë“œ ì‹œìŠ¤í…œ, ì¸ì¦ ì‹œìŠ¤í…œ, ë¦¬ë”ë³´ë“œ
   - **ê¸°ìˆ ì  ì„±ìˆ™ë„**: 95% (ì™„ì„± ë‹¨ê³„)

2. **ìŠ¤íƒ€í¬ë˜í”„íŠ¸ RPG**: v0.2.0ìœ¼ë¡œ ê¸°ë³¸ ê²Œì„ ì‹œìŠ¤í…œ ë° ì• ë‹ˆë©”ì´ì…˜ êµ¬í˜„
   - **ê°•ì **: GSAP ì• ë‹ˆë©”ì´ì…˜, ëª¨ë“ˆí™”ëœ êµ¬ì¡°, ë°˜ì‘í˜• UI
   - **ê°œì„  í•„ìš”**: ì‚¬ìš´ë“œ, ì „íˆ¬ ì‹œìŠ¤í…œ, í€˜ìŠ¤íŠ¸ ì‹œìŠ¤í…œ
   - **ê¸°ìˆ ì  ì„±ìˆ™ë„**: 85% (ê°œë°œ ì¤‘ë‹¨ê³„)

3. **í”„ë¡œì íŠ¸ êµ¬ì¡°**: ì²´ê³„ì ì¸ ë¬¸ì„œí™” ë° AI ì‘ì—… ê¸°ë¡ ì‹œìŠ¤í…œ êµ¬ì¶•
   - **ê°•ì **: AI ê¸°ë°˜ ê°œë°œ í”„ë¡œì„¸ìŠ¤, ì²´ê³„ì ì¸ ë¬¸ì„œí™”
   - **ê°œì„  í•„ìš”**: ìë™í™”ëœ í…ŒìŠ¤íŠ¸, CI/CD íŒŒì´í”„ë¼ì¸
   - **ê¸°ìˆ ì  ì„±ìˆ™ë„**: 90% (ì™„ì„± ë‹¨ê³„)

4. **GitHub ì—°ë™**: i-AI-helper/web_game ì €ì¥ì†Œì— ì„±ê³µì ìœ¼ë¡œ ì—…ë¡œë“œ
   - **ê°•ì **: ë²„ì „ ê´€ë¦¬, í˜‘ì—… í™˜ê²½ êµ¬ì¶•
   - **ê°œì„  í•„ìš”**: GitHub Actions, ìë™ ë°°í¬
   - **ê¸°ìˆ ì  ì„±ìˆ™ë„**: 80% (ê¸°ë³¸ ì™„ì„±)

#### ğŸ’­ AIì˜ ìƒê° ë° ì œì•ˆ (ì‹¬í™” ë¶„ì„)

**ì¦‰ì‹œ ì‹¤í–‰ ê°€ëŠ¥í•œ ê°œì„ ì‚¬í•­ (1-2ê°œì›”):**
- í…ŒíŠ¸ë¦­ìŠ¤ ê²Œì„ì˜ íšŒì›ê°€ì…/ë¡œê·¸ì¸ ì‹œìŠ¤í…œ êµ¬í˜„
- ìŠ¤íƒ€í¬ë˜í”„íŠ¸ RPGì˜ ì‚¬ìš´ë“œ ì‹œìŠ¤í…œ ì¶”ê°€
- í”„ë¡œì íŠ¸ ì „ì²´ì˜ ì„±ëŠ¥ ìµœì í™” ë° ëª¨ë°”ì¼ ì§€ì› ê°•í™”
- ìë™í™”ëœ í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œ êµ¬ì¶•

**ì¤‘ê¸° ê°œì„ ì‚¬í•­ (3-6ê°œì›”):**
- ê²Œì„ ê°„ ì—°ë™ ì‹œìŠ¤í…œ êµ¬ì¶•
- í†µí•© ì‚¬ìš©ì ê²½í—˜ ì œê³µ
- AI ê¸°ë°˜ ê²Œì„ ì¶”ì²œ ì‹œìŠ¤í…œ
- CI/CD íŒŒì´í”„ë¼ì¸ êµ¬ì¶•

**ì¥ê¸° ë¹„ì „ (6ê°œì›” ì´ìƒ):**
- í´ë¼ìš°ë“œ ê¸°ë°˜ ê²Œì„ í”Œë«í¼ êµ¬ì¶•
- ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë°˜ ê²Œì„ ë°¸ëŸ°ì‹±
- ë¸”ë¡ì²´ì¸ ê¸°ë°˜ ì•„ì´í…œ ì‹œìŠ¤í…œ
- AR/VR ì§€ì›

#### ğŸ”¬ ê¸°ìˆ ì  ë¶„ì„ ë° ì œì•ˆ

**ì„±ëŠ¥ ìµœì í™” ì˜ì—­:**
- **ë©”ëª¨ë¦¬ ê´€ë¦¬**: ê²Œì„ ì˜¤ë¸Œì íŠ¸ í’€ë§ ì‹œìŠ¤í…œ
- **ë Œë”ë§ ìµœì í™”**: WebGL ê°€ì† ë° ì˜¤í”„ìŠ¤í¬ë¦° ìº”ë²„ìŠ¤
- **ë„¤íŠ¸ì›Œí¬ ìµœì í™”**: WebSocket ì—°ê²° í’€ë§ ë° ì¬ì—°ê²° ë¡œì§

**ë³´ì•ˆ ê°•í™” ì˜ì—­:**
- **ì‚¬ìš©ì ì¸ì¦**: JWT í† í° ê¸°ë°˜ ë³´ì•ˆ ì‹œìŠ¤í…œ
- **ë°ì´í„° ë³´í˜¸**: í´ë¼ì´ì–¸íŠ¸-ì„œë²„ ê°„ ì•”í˜¸í™” í†µì‹ 
- **ì…ë ¥ ê²€ì¦**: XSS ë° CSRF ê³µê²© ë°©ì§€

**ì ‘ê·¼ì„± ê°œì„  ì˜ì—­:**
- **ìŠ¤í¬ë¦° ë¦¬ë” ì§€ì›**: ARIA ë¼ë²¨ ë° í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜
- **ìƒ‰ë§¹ ì§€ì›**: ë‹¤ì–‘í•œ ìƒ‰ìƒ í…Œë§ˆ ë° ëŒ€ë¹„ ì¡°ì •
- **ëª¨ë°”ì¼ ìµœì í™”**: í„°ì¹˜ ì œìŠ¤ì²˜ ë° ë°˜ì‘í˜• ë””ìì¸

---

### ğŸ® í…ŒíŠ¸ë¦­ìŠ¤ ê²Œì„ ì¶”ê°€ ê°œì„  ì œì•ˆ (ì‹¬í™”)

#### 1. ğŸµ ì‚¬ìš´ë“œ ì‹œìŠ¤í…œ í†µí•© (ê³ ë„í™”)
**ìš°ì„ ìˆœìœ„**: ë†’ìŒ ğŸ”´
**ì˜ˆìƒ ê°œë°œ ì‹œê°„**: 1-2ì£¼
**ê¸°ìˆ ì  ë³µì¡ë„**: ì¤‘ê°„

```javascript
// ê³ ë„í™”ëœ í…ŒíŠ¸ë¦­ìŠ¤ ì‚¬ìš´ë“œ ë§¤ë‹ˆì €
class AdvancedTetrisSoundManager {
    constructor() {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.sounds = new Map();
        this.bgm = null;
        this.masterVolume = 0.7;
        this.sfxVolume = 0.8;
        this.bgmVolume = 0.6;
        
        this.initSounds();
    }
    
    async initSounds() {
        const soundFiles = {
            lineClear: 'sounds/line-clear.mp3',
            tetris: 'sounds/tetris.mp3',
            rotate: 'sounds/rotate.mp3',
            drop: 'sounds/drop.mp3',
            gameOver: 'sounds/game-over.mp3',
            levelUp: 'sounds/level-up.mp3',
            combo: 'sounds/combo.mp3'
        };
        
        for (const [name, path] of Object.entries(soundFiles)) {
            try {
                const response = await fetch(path);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                this.sounds.set(name, audioBuffer);
            } catch (error) {
                console.warn(`Failed to load sound: ${name}`, error);
            }
        }
        
        // BGM ë¡œë“œ
        try {
            const bgmResponse = await fetch('sounds/tetris-theme.mp3');
            const bgmArrayBuffer = await bgmResponse.arrayBuffer();
            this.bgm = await this.audioContext.decodeAudioData(bgmArrayBuffer);
        } catch (error) {
            console.warn('Failed to load BGM', error);
        }
    }
    
    playSound(soundName, options = {}) {
        const audioBuffer = this.sounds.get(soundName);
        if (!audioBuffer) return;
        
        const source = this.audioContext.createBufferSource();
        const gainNode = this.audioContext.createGain();
        
        source.buffer = audioBuffer;
        source.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        // ë³¼ë¥¨ ì¡°ì ˆ
        gainNode.gain.value = (options.volume || 1) * this.sfxVolume * this.masterVolume;
        
        // í”¼ì¹˜ ì¡°ì ˆ
        if (options.pitch) {
            source.playbackRate.value = options.pitch;
        }
        
        // ë£¨í”„ ì„¤ì •
        source.loop = options.loop || false;
        
        source.start(0);
        return source;
    }
    
    playBGM() {
        if (!this.bgm) return;
        
        this.stopBGM();
        
        const source = this.audioContext.createBufferSource();
        const gainNode = this.audioContext.createGain();
        
        source.buffer = this.bgm;
        source.loop = true;
        source.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        gainNode.gain.value = this.bgmVolume * this.masterVolume;
        
        source.start(0);
        this.currentBGM = source;
    }
    
    stopBGM() {
        if (this.currentBGM) {
            this.currentBGM.stop();
            this.currentBGM = null;
        }
    }
    
    setMasterVolume(volume) {
        this.masterVolume = Math.max(0, Math.min(1, volume));
    }
    
    setSFXVolume(volume) {
        this.sfxVolume = Math.max(0, Math.min(1, volume));
    }
    
    setBGMVolume(volume) {
        this.bgmVolume = Math.max(0, Math.min(1, volume));
    }
}
```

#### 2. ğŸ” ê³ ê¸‰ ì¸ì¦ ì‹œìŠ¤í…œ (ì‹ ê·œ ì¶”ê°€)
**ìš°ì„ ìˆœìœ„**: ìµœê³  ğŸ”´
**ì˜ˆìƒ ê°œë°œ ì‹œê°„**: 3-4ì£¼
**ê¸°ìˆ ì  ë³µì¡ë„**: ë†’ìŒ

```javascript
// ê³ ê¸‰ ì¸ì¦ ì‹œìŠ¤í…œ
class AdvancedAuthSystem {
    constructor() {
        this.currentUser = null;
        this.isAuthenticated = false;
        this.token = null;
        this.refreshToken = null;
        this.apiBase = 'https://api.gameplatform.com';
        
        this.initAuth();
    }
    
    async initAuth() {
        // ì €ì¥ëœ í† í° í™•ì¸
        const savedToken = localStorage.getItem('authToken');
        const savedRefreshToken = localStorage.getItem('refreshToken');
        
        if (savedToken && savedRefreshToken) {
            try {
                await this.validateToken(savedToken);
            } catch (error) {
                await this.refreshAuthToken(savedRefreshToken);
            }
        }
    }
    
    async register(email, password, nickname, options = {}) {
        try {
            const response = await fetch(`${this.apiBase}/auth/register`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    email,
                    password,
                    nickname,
                    ...options
                })
            });
            
            if (!response.ok) {
                throw new Error('Registration failed');
            }
            
            const data = await response.json();
            await this.handleAuthSuccess(data);
            
            return { success: true, user: data.user };
        } catch (error) {
            console.error('Registration error:', error);
            return { success: false, error: error.message };
        }
    }
    
    async login(email, password, rememberMe = false) {
        try {
            const response = await fetch(`${this.apiBase}/auth/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ email, password, rememberMe })
            });
            
            if (!response.ok) {
                throw new Error('Login failed');
            }
            
            const data = await response.json();
            await this.handleAuthSuccess(data, rememberMe);
            
            return { success: true, user: data.user };
        } catch (error) {
            console.error('Login error:', error);
            return { success: false, error: error.message };
        }
    }
    
    async handleAuthSuccess(authData, rememberMe = false) {
        this.currentUser = authData.user;
        this.isAuthenticated = true;
        this.token = authData.accessToken;
        this.refreshToken = authData.refreshToken;
        
        if (rememberMe) {
            localStorage.setItem('authToken', this.token);
            localStorage.setItem('refreshToken', this.refreshToken);
            localStorage.setItem('userData', JSON.stringify(this.currentUser));
        } else {
            sessionStorage.setItem('authToken', this.token);
            sessionStorage.setItem('refreshToken', this.refreshToken);
            sessionStorage.setItem('userData', JSON.stringify(this.currentUser));
        }
        
        // ì´ë²¤íŠ¸ ë°œìƒ
        this.dispatchAuthEvent('login', this.currentUser);
    }
    
    async logout() {
        try {
            if (this.token) {
                await fetch(`${this.apiBase}/auth/logout`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${this.token}`
                    }
                });
            }
        } catch (error) {
            console.warn('Logout API call failed:', error);
        }
        
        this.clearAuthData();
        this.dispatchAuthEvent('logout', null);
    }
    
    clearAuthData() {
        this.currentUser = null;
        this.isAuthenticated = false;
        this.token = null;
        this.refreshToken = null;
        
        localStorage.removeItem('authToken');
        localStorage.removeItem('refreshToken');
        localStorage.removeItem('userData');
        sessionStorage.removeItem('authToken');
        sessionStorage.removeItem('refreshToken');
        sessionStorage.removeItem('userData');
    }
    
    async refreshAuthToken(refreshToken) {
        try {
            const response = await fetch(`${this.apiBase}/auth/refresh`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ refreshToken })
            });
            
            if (!response.ok) {
                throw new Error('Token refresh failed');
            }
            
            const data = await response.json();
            await this.handleAuthSuccess(data);
            
            return true;
        } catch (error) {
            console.error('Token refresh error:', error);
            this.clearAuthData();
            return false;
        }
    }
    
    async validateToken(token) {
        try {
            const response = await fetch(`${this.apiBase}/auth/validate`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });
            
            if (!response.ok) {
                throw new Error('Token validation failed');
            }
            
            const data = await response.json();
            this.currentUser = data.user;
            this.isAuthenticated = true;
            
            return true;
        } catch (error) {
            console.error('Token validation error:', error);
            return false;
        }
    }
    
    dispatchAuthEvent(type, user) {
        const event = new CustomEvent('authChange', {
            detail: { type, user, isAuthenticated: this.isAuthenticated }
        });
        window.dispatchEvent(event);
    }
    
    // API ìš”ì²­ì„ ìœ„í•œ í—¤ë” ìƒì„±
    getAuthHeaders() {
        return {
            'Authorization': `Bearer ${this.token}`,
            'Content-Type': 'application/json'
        };
    }
}
```

#### 3. ğŸ† ê³ ê¸‰ ë¦¬ë”ë³´ë“œ ì‹œìŠ¤í…œ (ê³ ë„í™”)
**ìš°ì„ ìˆœìœ„**: ì¤‘ê°„ ğŸŸ¡
**ì˜ˆìƒ ê°œë°œ ì‹œê°„**: 2-3ì£¼
**ê¸°ìˆ ì  ë³µì¡ë„**: ì¤‘ê°„

```javascript
// ê³ ê¸‰ ë¦¬ë”ë³´ë“œ ì‹œìŠ¤í…œ
class AdvancedLeaderboardSystem {
    constructor() {
        this.leaderboards = new Map();
        this.currentSeason = 1;
        this.seasonStartDate = new Date('2025-01-01');
        this.seasonDuration = 90; // 90ì¼
        
        this.initLeaderboards();
    }
    
    initLeaderboards() {
        // ê¸€ë¡œë²Œ ë¦¬ë”ë³´ë“œ
        this.leaderboards.set('global', {
            name: 'ê¸€ë¡œë²Œ',
            type: 'global',
            data: [],
            lastUpdated: null
        });
        
        // ì‹œì¦Œ ë¦¬ë”ë³´ë“œ
        this.leaderboards.set('season', {
            name: `ì‹œì¦Œ ${this.currentSeason}`,
            type: 'season',
            data: [],
            lastUpdated: null,
            startDate: this.seasonStartDate,
            endDate: new Date(this.seasonStartDate.getTime() + this.seasonDuration * 24 * 60 * 60 * 1000)
        });
        
        // ì¹œêµ¬ ë¦¬ë”ë³´ë“œ
        this.leaderboards.set('friends', {
            name: 'ì¹œêµ¬',
            type: 'friends',
            data: [],
            lastUpdated: null
        });
        
        // êµ­ê°€ë³„ ë¦¬ë”ë³´ë“œ
        this.leaderboards.set('country', {
            name: 'êµ­ê°€ë³„',
            type: 'country',
            data: [],
            lastUpdated: null
        });
    }
    
    async submitScore(score, lines, level, combo, time, userId) {
        const scoreData = {
            userId,
            score,
            lines,
            level,
            combo,
            time,
            timestamp: new Date().toISOString(),
            season: this.currentSeason
        };
        
        try {
            // ë¡œì»¬ ì €ì¥
            this.updateLocalLeaderboard(scoreData);
            
            // ì„œë²„ ì „ì†¡
            await this.submitToServer(scoreData);
            
            // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
            this.broadcastScoreUpdate(scoreData);
            
            return { success: true, rank: this.getRank(score) };
        } catch (error) {
            console.error('Score submission error:', error);
            return { success: false, error: error.message };
        }
    }
    
    updateLocalLeaderboard(scoreData) {
        for (const [key, leaderboard] of this.leaderboards) {
            if (key === 'season' && scoreData.season !== this.currentSeason) {
                continue; // í˜„ì¬ ì‹œì¦Œì´ ì•„ë‹Œ ê²½ìš° ìŠ¤í‚µ
            }
            
            leaderboard.data.push(scoreData);
            leaderboard.data.sort((a, b) => b.score - a.score);
            
            // ìƒìœ„ 1000ëª…ë§Œ ìœ ì§€
            if (leaderboard.data.length > 1000) {
                leaderboard.data = leaderboard.data.slice(0, 1000);
            }
            
            leaderboard.lastUpdated = new Date();
        }
    }
    
    getRank(score) {
        const globalLeaderboard = this.leaderboards.get('global');
        const index = globalLeaderboard.data.findIndex(entry => entry.score === score);
        return index >= 0 ? index + 1 : null;
    }
    
    async submitToServer(scoreData) {
        const response = await fetch('/api/leaderboard/submit', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(scoreData)
        });
        
        if (!response.ok) {
            throw new Error('Server submission failed');
        }
        
        return await response.json();
    }
    
    broadcastScoreUpdate(scoreData) {
        // WebSocketì„ í†µí•œ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
        if (window.gameSocket && window.gameSocket.readyState === WebSocket.OPEN) {
            window.gameSocket.send(JSON.stringify({
                type: 'scoreUpdate',
                data: scoreData
            }));
        }
        
        // ë¡œì»¬ ì´ë²¤íŠ¸ ë°œìƒ
        const event = new CustomEvent('leaderboardUpdate', {
            detail: { scoreData, leaderboards: this.leaderboards }
        });
        window.dispatchEvent(event);
    }
    
    getLeaderboard(type, limit = 100) {
        const leaderboard = this.leaderboards.get(type);
        if (!leaderboard) return [];
        
        return leaderboard.data.slice(0, limit);
    }
    
    getUserRank(userId, type = 'global') {
        const leaderboard = this.leaderboards.get(type);
        if (!leaderboard) return null;
        
        const index = leaderboard.data.findIndex(entry => entry.userId === userId);
        return index >= 0 ? index + 1 : null;
    }
    
    getUserStats(userId) {
        const stats = {
            global: this.getUserRank(userId, 'global'),
            season: this.getUserRank(userId, 'season'),
            friends: this.getUserRank(userId, 'friends'),
            country: this.getUserRank(userId, 'country'),
            totalGames: 0,
            averageScore: 0,
            bestScore: 0,
            totalLines: 0
        };
        
        // í†µê³„ ê³„ì‚°
        for (const leaderboard of this.leaderboards.values()) {
            const userEntries = leaderboard.data.filter(entry => entry.userId === userId);
            if (userEntries.length > 0) {
                stats.totalGames += userEntries.length;
                stats.totalLines += userEntries.reduce((sum, entry) => sum + entry.lines, 0);
                stats.averageScore = userEntries.reduce((sum, entry) => sum + entry.score, 0) / userEntries.length;
                stats.bestScore = Math.max(stats.bestScore, ...userEntries.map(entry => entry.score));
            }
        }
        
        return stats;
    }
    
    checkSeasonEnd() {
        const now = new Date();
        const seasonEnd = new Date(this.seasonStartDate.getTime() + this.seasonDuration * 24 * 60 * 60 * 1000);
        
        if (now >= seasonEnd) {
            this.endSeason();
        }
    }
    
    endSeason() {
        // ì‹œì¦Œ ì¢…ë£Œ ì²˜ë¦¬
        const seasonLeaderboard = this.leaderboards.get('season');
        
        // ì‹œì¦Œ ê²°ê³¼ ì €ì¥
        this.saveSeasonResults(seasonLeaderboard);
        
        // ìƒˆë¡œìš´ ì‹œì¦Œ ì‹œì‘
        this.currentSeason++;
        this.seasonStartDate = new Date();
        
        // ì‹œì¦Œ ë¦¬ë”ë³´ë“œ ì´ˆê¸°í™”
        seasonLeaderboard.data = [];
        seasonLeaderboard.name = `ì‹œì¦Œ ${this.currentSeason}`;
        seasonLeaderboard.startDate = this.seasonStartDate;
        seasonLeaderboard.endDate = new Date(this.seasonStartDate.getTime() + this.seasonDuration * 24 * 60 * 60 * 1000);
        seasonLeaderboard.lastUpdated = new Date();
        
        // ì‹œì¦Œ ì¢…ë£Œ ì´ë²¤íŠ¸ ë°œìƒ
        this.dispatchSeasonEndEvent();
    }
    
    saveSeasonResults(seasonLeaderboard) {
        const seasonData = {
            season: this.currentSeason - 1,
            startDate: seasonLeaderboard.startDate,
            endDate: seasonLeaderboard.endDate,
            participants: seasonLeaderboard.data.length,
            topPlayers: seasonLeaderboard.data.slice(0, 10),
            timestamp: new Date().toISOString()
        };
        
        // ë¡œì»¬ ì €ì¥
        const seasonHistory = JSON.parse(localStorage.getItem('seasonHistory') || '[]');
        seasonHistory.push(seasonData);
        localStorage.setItem('seasonHistory', JSON.stringify(seasonHistory));
        
        // ì„œë²„ ì „ì†¡
        this.submitSeasonResults(seasonData);
    }
    
    async submitSeasonResults(seasonData) {
        try {
            await fetch('/api/leaderboard/season-end', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(seasonData)
            });
        } catch (error) {
            console.error('Season results submission failed:', error);
        }
    }
    
    dispatchSeasonEndEvent() {
        const event = new CustomEvent('seasonEnd', {
            detail: { 
                season: this.currentSeason - 1,
                newSeason: this.currentSeason,
                startDate: this.seasonStartDate
            }
        });
        window.dispatchEvent(event);
    }
}

#### 4. ğŸ¨ ê³ ê¸‰ í…Œë§ˆ ì‹œìŠ¤í…œ (ì‹ ê·œ ì¶”ê°€)
**ìš°ì„ ìˆœìœ„**: ì¤‘ê°„ ğŸŸ¡
**ì˜ˆìƒ ê°œë°œ ì‹œê°„**: 2-3ì£¼
**ê¸°ìˆ ì  ë³µì¡ë„**: ì¤‘ê°„

```javascript
// ê³ ê¸‰ í…Œë§ˆ ì‹œìŠ¤í…œ
class AdvancedThemeManager {
    constructor() {
        this.themes = new Map();
        this.currentTheme = 'classic';
        this.customThemes = new Map();
        
        this.initDefaultThemes();
        this.loadCustomThemes();
    }
    
    initDefaultThemes() {
        const defaultThemes = {
            classic: {
                name: 'í´ë˜ì‹',
                description: 'ì›ì¡° í…ŒíŠ¸ë¦­ìŠ¤ ìŠ¤íƒ€ì¼',
                colors: {
                    I: '#00f5ff', O: '#ffff00', T: '#a000f0',
                    S: '#00f000', Z: '#f00000', J: '#0000f0', L: '#ffa500'
                },
                background: '#000000',
                grid: '#333333',
                ui: '#ffffff',
                accent: '#00ff00'
            },
            neon: {
                name: 'ë„¤ì˜¨',
                description: 'ë°ê³  í™”ë ¤í•œ ë„¤ì˜¨ ìŠ¤íƒ€ì¼',
                colors: {
                    I: '#ff0080', O: '#00ff80', T: '#8000ff',
                    S: '#ff8000', Z: '#80ff00', J: '#0080ff', L: '#ff0080'
                },
                background: '#0a0a0a',
                grid: '#1a1a1a',
                ui: '#00ffff',
                accent: '#ff00ff'
            },
            retro: {
                name: 'ë ˆíŠ¸ë¡œ',
                description: '80ë…„ëŒ€ ë ˆíŠ¸ë¡œ ê°ì„±',
                colors: {
                    I: '#ff6b35', O: '#f7931e', T: '#ffd23f',
                    S: '#6bcf7f', Z: '#4ecdc4', J: '#45b7d1', L: '#96ceb4'
                },
                background: '#2c1810',
                grid: '#4a2c1a',
                ui: '#f4a261',
                accent: '#e76f51'
            }
        };
        
        for (const [key, theme] of Object.entries(defaultThemes)) {
            this.themes.set(key, theme);
        }
    }
    
    loadCustomThemes() {
        const savedThemes = localStorage.getItem('customThemes');
        if (savedThemes) {
            try {
                const customThemes = JSON.parse(savedThemes);
                for (const [key, theme] of Object.entries(customThemes)) {
                    this.customThemes.set(key, theme);
                }
            } catch (error) {
                console.warn('Failed to load custom themes:', error);
            }
        }
    }
    
    applyTheme(themeName) {
        const theme = this.themes.get(themeName) || this.customThemes.get(themeName);
        if (!theme) return false;
        
        this.currentTheme = themeName;
        this.updateBlockColors(theme.colors);
        this.updateUI(theme);
        this.saveThemePreference(themeName);
        
        // í…Œë§ˆ ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
        this.dispatchThemeChangeEvent(theme);
        
        return true;
    }
    
    updateBlockColors(colors) {
        const root = document.documentElement;
        for (const [blockType, color] of Object.entries(colors)) {
            root.style.setProperty(`--tetris-${blockType.toLowerCase()}-color`, color);
        }
    }
    
    updateUI(theme) {
        const root = document.documentElement;
        root.style.setProperty('--game-background', theme.background);
        root.style.setProperty('--game-grid', theme.grid);
        root.style.setProperty('--game-ui', theme.ui);
        root.style.setProperty('--game-accent', theme.accent);
    }
    
    saveThemePreference(themeName) {
        localStorage.setItem('selectedTheme', themeName);
    }
    
    createCustomTheme(name, colors, background, grid, ui, accent) {
        const customTheme = {
            name,
            description: 'ì‚¬ìš©ì ì •ì˜ í…Œë§ˆ',
            colors,
            background,
            grid,
            ui,
            accent,
            isCustom: true,
            createdAt: new Date().toISOString()
        };
        
        const themeKey = `custom_${Date.now()}`;
        this.customThemes.set(themeKey, customTheme);
        this.saveCustomThemes();
        
        return themeKey;
    }
    
    saveCustomThemes() {
        const customThemes = {};
        for (const [key, theme] of this.customThemes) {
            customThemes[key] = theme;
        }
        localStorage.setItem('customThemes', JSON.stringify(customThemes));
    }
    
    deleteCustomTheme(themeKey) {
        if (this.customThemes.has(themeKey)) {
            this.customThemes.delete(themeKey);
            this.saveCustomThemes();
            return true;
        }
        return false;
    }
    
    getAllThemes() {
        const allThemes = {};
        
        // ê¸°ë³¸ í…Œë§ˆ
        for (const [key, theme] of this.themes) {
            allThemes[key] = { ...theme, isDefault: true };
        }
        
        // ì»¤ìŠ¤í…€ í…Œë§ˆ
        for (const [key, theme] of this.customThemes) {
            allThemes[key] = { ...theme, isCustom: true };
        }
        
        return allThemes;
    }
    
    dispatchThemeChangeEvent(theme) {
        const event = new CustomEvent('themeChange', {
            detail: { theme, themeName: this.currentTheme }
        });
        window.dispatchEvent(event);
    }
}
```

---

### ğŸš€ ìŠ¤íƒ€í¬ë˜í”„íŠ¸ RPG ì¶”ê°€ ê°œì„  ì œì•ˆ (ì‹¬í™”)

#### 1. ğŸŒ ê³ ê¸‰ ë©€í‹°í”Œë ˆì´ì–´ ì‹œìŠ¤í…œ (ê³ ë„í™”)
**ìš°ì„ ìˆœìœ„**: ë†’ìŒ ğŸ”´
**ì˜ˆìƒ ê°œë°œ ì‹œê°„**: 4-6ì£¼
**ê¸°ìˆ ì  ë³µì¡ë„**: ë†’ìŒ

```javascript
// ê³ ê¸‰ ë©€í‹°í”Œë ˆì´ì–´ ë§¤ë‹ˆì €
class AdvancedMultiplayerManager {
    constructor() {
        this.players = new Map();
        this.rooms = new Map();
        this.socket = null;
        this.currentRoom = null;
        this.isHost = false;
        this.syncInterval = null;
        
        this.initWebSocket();
    }
    
    initWebSocket() {
        this.socket = new WebSocket('wss://gameplatform.com/multiplayer');
        
        this.socket.onopen = () => {
            console.log('Multiplayer connection established');
            this.authenticate();
        };
        
        this.socket.onmessage = (event) => {
            const message = JSON.parse(event.data);
            this.handleMessage(message);
        };
        
        this.socket.onclose = () => {
            console.log('Multiplayer connection closed');
            this.reconnect();
        };
    }
    
    async authenticate() {
        const token = localStorage.getItem('authToken');
        if (token) {
            this.socket.send(JSON.stringify({
                type: 'authenticate',
                token: token
            }));
        }
    }
    
    async createRoom(roomName, maxPlayers = 4, gameMode = 'coop') {
        const room = {
            id: this.generateRoomId(),
            name: roomName,
            maxPlayers,
            gameMode,
            players: [],
            status: 'waiting',
            createdAt: new Date().toISOString(),
            settings: this.getDefaultRoomSettings()
        };
        
        this.rooms.set(room.id, room);
        this.currentRoom = room.id;
        this.isHost = true;
        
        // ì„œë²„ì— ë°© ìƒì„± ìš”ì²­
        this.socket.send(JSON.stringify({
            type: 'createRoom',
            room: room
        }));
        
        return room;
    }
    
    async joinRoom(roomId, playerData) {
        const room = this.rooms.get(roomId);
        if (!room || room.players.length >= room.maxPlayers) {
            return { success: false, error: 'Room is full or does not exist' };
        }
        
        const player = {
            id: playerData.id,
            name: playerData.name,
            avatar: playerData.avatar,
            level: playerData.level,
            joinedAt: new Date().toISOString(),
            isReady: false
        };
        
        room.players.push(player);
        this.currentRoom = roomId;
        this.isHost = false;
        
        // ì„œë²„ì— ì°¸ê°€ ìš”ì²­
        this.socket.send(JSON.stringify({
            type: 'joinRoom',
            roomId: roomId,
            player: player
        }));
        
        return { success: true, room: room };
    }
    
    startGame() {
        if (!this.isHost || !this.currentRoom) return false;
        
        const room = this.rooms.get(this.currentRoom);
        if (room.players.length < 2) return false;
        
        room.status = 'playing';
        room.gameStartTime = new Date().toISOString();
        
        // ê²Œì„ ì‹œì‘ ë™ê¸°í™”
        this.socket.send(JSON.stringify({
            type: 'startGame',
            roomId: this.currentRoom
        }));
        
        // ê²Œì„ ìƒíƒœ ë™ê¸°í™” ì‹œì‘
        this.startGameSync();
        
        return true;
    }
    
    startGameSync() {
        this.syncInterval = setInterval(() => {
            if (this.currentRoom && this.rooms.get(this.currentRoom).status === 'playing') {
                this.syncGameState();
            }
        }, 100); // 100msë§ˆë‹¤ ë™ê¸°í™”
    }
    
    syncGameState() {
        const gameState = this.getCurrentGameState();
        this.socket.send(JSON.stringify({
            type: 'gameStateSync',
            roomId: this.currentRoom,
            gameState: gameState
        }));
    }
    
    getCurrentGameState() {
        // í˜„ì¬ ê²Œì„ ìƒíƒœ ë°˜í™˜
        return {
            timestamp: Date.now(),
            playerStates: Array.from(this.players.values()).map(player => ({
                id: player.id,
                position: player.position,
                health: player.health,
                resources: player.resources,
                actions: player.recentActions
            }))
        };
    }
    
    handleMessage(message) {
        switch (message.type) {
            case 'playerJoined':
                this.handlePlayerJoined(message);
                break;
            case 'playerLeft':
                this.handlePlayerLeft(message);
                break;
            case 'gameStateUpdate':
                this.handleGameStateUpdate(message);
                break;
            case 'chatMessage':
                this.handleChatMessage(message);
                break;
            case 'gameEnd':
                this.handleGameEnd(message);
                break;
        }
    }
    
    handlePlayerJoined(message) {
        const { roomId, player } = message;
        const room = this.rooms.get(roomId);
        if (room) {
            room.players.push(player);
            this.dispatchEvent('playerJoined', { room, player });
        }
    }
    
    handlePlayerLeft(message) {
        const { roomId, playerId } = message;
        const room = this.rooms.get(roomId);
        if (room) {
            room.players = room.players.filter(p => p.id !== playerId);
            this.dispatchEvent('playerLeft', { room, playerId });
        }
    }
    
    handleGameStateUpdate(message) {
        const { gameState } = message;
        this.updateGameState(gameState);
        this.dispatchEvent('gameStateUpdate', { gameState });
    }
    
    updateGameState(gameState) {
        // ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸
        for (const playerState of gameState.playerStates) {
            const player = this.players.get(playerState.id);
            if (player) {
                Object.assign(player, playerState);
            }
        }
    }
    
    sendChatMessage(message) {
        if (this.currentRoom) {
            this.socket.send(JSON.stringify({
                type: 'chatMessage',
                roomId: this.currentRoom,
                message: message,
                timestamp: new Date().toISOString()
            }));
        }
    }
    
    dispatchEvent(eventType, data) {
        const event = new CustomEvent(`multiplayer_${eventType}`, { detail: data });
        window.dispatchEvent(event);
    }
    
    disconnect() {
        if (this.socket) {
            this.socket.close();
        }
        if (this.syncInterval) {
            clearInterval(this.syncInterval);
        }
        this.currentRoom = null;
        this.isHost = false;
    }
    
    reconnect() {
        setTimeout(() => {
            this.initWebSocket();
        }, 5000); // 5ì´ˆ í›„ ì¬ì—°ê²° ì‹œë„
    }
}
```

#### 2. ğŸ­ ê³ ê¸‰ í€˜ìŠ¤íŠ¸ ì‹œìŠ¤í…œ (ì‹ ê·œ ì¶”ê°€)
**ìš°ì„ ìˆœìœ„**: ì¤‘ê°„ ğŸŸ¡
**ì˜ˆìƒ ê°œë°œ ì‹œê°„**: 6-8ì£¼
**ê¸°ìˆ ì  ë³µì¡ë„**: ë†’ìŒ

```javascript
// ê³ ê¸‰ í€˜ìŠ¤íŠ¸ ì‹œìŠ¤í…œ
class AdvancedQuestSystem {
    constructor() {
        this.quests = new Map();
        this.activeQuests = new Map();
        this.completedQuests = new Set();
        this.questChains = new Map();
        this.dailyQuests = new Map();
        this.weeklyQuests = new Map();
        
        this.initQuests();
        this.loadQuestProgress();
    }
    
    initQuests() {
        // ë©”ì¸ ìŠ¤í† ë¦¬ í€˜ìŠ¤íŠ¸
        this.initMainStoryQuests();
        
        // ì‚¬ì´ë“œ í€˜ìŠ¤íŠ¸
        this.initSideQuests();
        
        // ì¼ì¼ í€˜ìŠ¤íŠ¸
        this.initDailyQuests();
        
        // ì£¼ê°„ í€˜ìŠ¤íŠ¸
        this.initWeeklyQuests();
        
        // ì—…ì  í€˜ìŠ¤íŠ¸
        this.initAchievementQuests();
    }
    
    initMainStoryQuests() {
        const mainQuests = [
            {
                id: 'main_001',
                title: 'í…Œë€ì˜ ì‹œì‘',
                description: 'í…Œë€ì˜ ì¼ê°œ ì‹œë¯¼ìœ¼ë¡œì„œ ìƒˆë¡œìš´ ì‚¶ì„ ì‹œì‘í•©ë‹ˆë‹¤.',
                type: 'main',
                chapter: 1,
                requirements: [],
                objectives: [
                    { type: 'build', target: 'command_center', count: 1, description: 'ì»¤ë§¨ë“œ ì„¼í„° ê±´ì„¤' },
                    { type: 'collect', target: 'mineral', count: 100, description: 'ë¯¸ë„¤ë„ 100ê°œ ìˆ˜ì§‘' }
                ],
                rewards: {
                    experience: 500,
                    minerals: 200,
                    gas: 50,
                    items: ['basic_toolkit']
                },
                nextQuest: 'main_002'
            },
            {
                id: 'main_002',
                title: 'ì²« ë²ˆì§¸ ê±´ë¬¼',
                description: 'ë” ë§ì€ ê±´ë¬¼ì„ ê±´ì„¤í•˜ì—¬ ê¸°ë°˜ì„ ë‹¤ì§‘ë‹ˆë‹¤.',
                type: 'main',
                chapter: 1,
                requirements: ['main_001'],
                objectives: [
                    { type: 'build', target: 'barracks', count: 1, description: 'ë°°ëŸ­ìŠ¤ ê±´ì„¤' },
                    { type: 'train', target: 'mining', count: 5, description: 'ì±„ê´‘ ìŠ¤í‚¬ 5íšŒ í›ˆë ¨' }
                ],
                rewards: {
                    experience: 800,
                    minerals: 300,
                    gas: 100,
                    items: ['advanced_toolkit']
                },
                nextQuest: 'main_003'
            }
        ];
        
        for (const quest of mainQuests) {
            this.quests.set(quest.id, quest);
        }
    }
    
    initSideQuests() {
        const sideQuests = [
            {
                id: 'side_001',
                title: 'ê´‘ë¶€ì˜ ë„ì „',
                description: 'í•˜ë£¨ ë™ì•ˆ ê´‘ë¶€ë¡œ ì¼í•˜ë©° ë¯¸ë„¤ë„ì„ ìˆ˜ì§‘í•˜ì„¸ìš”.',
                type: 'side',
                category: 'mining',
                requirements: [],
                objectives: [
                    { type: 'work', target: 'mining', count: 10, description: 'ì±„ê´‘ ì‘ì—… 10íšŒ ìˆ˜í–‰' },
                    { type: 'collect', target: 'mineral', count: 500, description: 'ë¯¸ë„¤ë„ 500ê°œ ìˆ˜ì§‘' }
                ],
                rewards: {
                    experience: 200,
                    minerals: 100,
                    items: ['mining_boost']
                },
                timeLimit: 86400000 // 24ì‹œê°„
            }
        ];
        
        for (const quest of sideQuests) {
            this.quests.set(quest.id, quest);
        }
    }
    
    initDailyQuests() {
        this.generateDailyQuests();
    }
    
    generateDailyQuests() {
        const dailyQuestTemplates = [
            {
                id: 'daily_mining',
                title: 'ì¼ì¼ ì±„ê´‘',
                description: 'ì˜¤ëŠ˜ í•˜ë£¨ ë™ì•ˆ ë¯¸ë„¤ë„ì„ ìˆ˜ì§‘í•˜ì„¸ìš”.',
                type: 'daily',
                category: 'mining',
                objectives: [
                    { type: 'collect', target: 'mineral', count: 1000, description: 'ë¯¸ë„¤ë„ 1000ê°œ ìˆ˜ì§‘' }
                ],
                rewards: {
                    experience: 100,
                    minerals: 50,
                    currency: 10
                }
            },
            {
                id: 'daily_training',
                title: 'ì¼ì¼ í›ˆë ¨',
                description: 'ì˜¤ëŠ˜ í•˜ë£¨ ë™ì•ˆ ìŠ¤í‚¬ì„ í–¥ìƒì‹œí‚¤ì„¸ìš”.',
                type: 'daily',
                category: 'training',
                objectives: [
                    { type: 'train', target: 'any', count: 5, description: 'ìŠ¤í‚¬ í›ˆë ¨ 5íšŒ ìˆ˜í–‰' }
                ],
                rewards: {
                    experience: 100,
                    skillPoints: 2,
                    currency: 10
                }
            }
        ];
        
        for (const template of dailyQuestTemplates) {
            const quest = this.generateDailyQuestFromTemplate(template);
            this.dailyQuests.set(quest.id, quest);
        }
    }
    
    generateDailyQuestFromTemplate(template) {
        const today = new Date().toDateString();
        const questId = `${template.id}_${Date.now()}`;
        
        return {
            ...template,
            id: questId,
            generatedAt: today,
            expiresAt: new Date(Date.now() + 86400000), // 24ì‹œê°„ í›„ ë§Œë£Œ
            isCompleted: false
        };
    }
    
    acceptQuest(questId) {
        const quest = this.quests.get(questId);
        if (!quest || this.activeQuests.has(questId)) return false;
        
        // í€˜ìŠ¤íŠ¸ ìš”êµ¬ì‚¬í•­ í™•ì¸
        if (!this.checkQuestRequirements(quest)) return false;
        
        // í€˜ìŠ¤íŠ¸ ìˆ˜ë½
        this.activeQuests.set(questId, {
            ...quest,
            acceptedAt: new Date().toISOString(),
            progress: this.initializeQuestProgress(quest),
            isCompleted: false
        });
        
        this.saveQuestProgress();
        this.dispatchEvent('questAccepted', { quest });
        
        return true;
    }
    
    checkQuestRequirements(quest) {
        if (!quest.requirements || quest.requirements.length === 0) return true;
        
        for (const requirement of quest.requirements) {
            if (!this.completedQuests.has(requirement)) return false;
        }
        
        return true;
    }
    
    initializeQuestProgress(quest) {
        const progress = {};
        
        for (const objective of quest.objectives) {
            progress[objective.type] = {
                current: 0,
                target: objective.count,
                completed: false
            };
        }
        
        return progress;
    }
    
    updateQuestProgress(questId, actionType, target, count = 1) {
        const activeQuest = this.activeQuests.get(questId);
        if (!activeQuest) return false;
        
        let progressUpdated = false;
        
        for (const objective of activeQuest.objectives) {
            if (objective.type === actionType && objective.target === target) {
                const progress = activeQuest.progress[objective.type];
                progress.current = Math.min(progress.current + count, progress.target);
                progress.completed = progress.current >= progress.target;
                progressUpdated = true;
            }
        }
        
        if (progressUpdated) {
            this.checkQuestCompletion(questId);
            this.saveQuestProgress();
            this.dispatchEvent('questProgressUpdated', { questId, progress: activeQuest.progress });
        }
        
        return progressUpdated;
    }
    
    checkQuestCompletion(questId) {
        const activeQuest = this.activeQuests.get(questId);
        if (!activeQuest) return false;
        
        const allCompleted = activeQuest.objectives.every(objective => {
            const progress = activeQuest.progress[objective.type];
            return progress.completed;
        });
        
        if (allCompleted) {
            this.completeQuest(questId);
        }
        
        return allCompleted;
    }
    
    completeQuest(questId) {
        const activeQuest = this.activeQuests.get(questId);
        if (!activeQuest) return false;
        
        // í€˜ìŠ¤íŠ¸ ì™„ë£Œ ì²˜ë¦¬
        activeQuest.isCompleted = true;
        activeQuest.completedAt = new Date().toISOString();
        
        // ë³´ìƒ ì§€ê¸‰
        this.grantQuestRewards(activeQuest);
        
        // ì™„ë£Œëœ í€˜ìŠ¤íŠ¸ ëª©ë¡ì— ì¶”ê°€
        this.completedQuests.add(questId);
        
        // í™œì„± í€˜ìŠ¤íŠ¸ì—ì„œ ì œê±°
        this.activeQuests.delete(questId);
        
        // ë‹¤ìŒ í€˜ìŠ¤íŠ¸ ì²´ì¸ í™•ì¸
        this.checkQuestChain(activeQuest);
        
        this.saveQuestProgress();
        this.dispatchEvent('questCompleted', { quest: activeQuest });
        
        return true;
    }
    
    grantQuestRewards(quest) {
        // ê²½í—˜ì¹˜ ì§€ê¸‰
        if (quest.rewards.experience) {
            // ê²Œì„ ì‹œìŠ¤í…œì— ê²½í—˜ì¹˜ ì¶”ê°€
            this.addExperience(quest.rewards.experience);
        }
        
        // ìì› ì§€ê¸‰
        if (quest.rewards.minerals) {
            this.addMinerals(quest.rewards.minerals);
        }
        
        if (quest.rewards.gas) {
            this.addGas(quest.rewards.gas);
        }
        
        // ì•„ì´í…œ ì§€ê¸‰
        if (quest.rewards.items) {
            for (const item of quest.rewards.items) {
                this.addItem(item);
            }
        }
        
        // í†µí™” ì§€ê¸‰
        if (quest.rewards.currency) {
            this.addCurrency(quest.rewards.currency);
        }
    }
    
    checkQuestChain(completedQuest) {
        if (completedQuest.nextQuest) {
            const nextQuest = this.quests.get(completedQuest.nextQuest);
            if (nextQuest && this.checkQuestRequirements(nextQuest)) {
                // ë‹¤ìŒ í€˜ìŠ¤íŠ¸ ìë™ ìˆ˜ë½
                this.acceptQuest(completedQuest.nextQuest);
            }
        }
    }
    
    saveQuestProgress() {
        const progress = {
            activeQuests: Array.from(this.activeQuests.entries()),
            completedQuests: Array.from(this.completedQuests),
            lastSaved: new Date().toISOString()
        };
        
        localStorage.setItem('questProgress', JSON.stringify(progress));
    }
    
    loadQuestProgress() {
        const savedProgress = localStorage.getItem('questProgress');
        if (savedProgress) {
            try {
                const progress = JSON.parse(savedProgress);
                
                // í™œì„± í€˜ìŠ¤íŠ¸ ë³µì›
                for (const [questId, questData] of progress.activeQuests) {
                    this.activeQuests.set(questId, questData);
                }
                
                // ì™„ë£Œëœ í€˜ìŠ¤íŠ¸ ë³µì›
                for (const questId of progress.completedQuests) {
                    this.completedQuests.add(questId);
                }
            } catch (error) {
                console.warn('Failed to load quest progress:', error);
            }
        }
    }
    
    dispatchEvent(eventType, data) {
        const event = new CustomEvent(`quest_${eventType}`, { detail: data });
        window.dispatchEvent(event);
    }
}
```

#### 3. ğŸ¤– ê³ ê¸‰ AI ì  ì‹œìŠ¤í…œ (ê³ ë„í™”)
**ìš°ì„ ìˆœìœ„**: ì¤‘ê°„ ğŸŸ¡
**ì˜ˆìƒ ê°œë°œ ì‹œê°„**: 4-5ì£¼
**ê¸°ìˆ ì  ë³µì¡ë„**: ë†’ìŒ

```javascript
// ê³ ê¸‰ AI ì  ì‹œìŠ¤í…œ
class AdvancedEnemyAI {
    constructor(difficulty = 'normal') {
        this.difficulty = difficulty;
        this.behaviorPatterns = this.getBehaviorPatterns();
        this.currentPattern = 0;
        this.adaptationLevel = 0;
        this.memory = new Map();
        this.personality = this.generatePersonality();
        
        this.initAI();
    }
    
    initAI() {
        this.behaviorTree = this.createBehaviorTree();
        this.decisionHistory = [];
        this.lastActionTime = Date.now();
        this.actionCooldown = this.getActionCooldown();
    }
    
    getBehaviorPatterns() {
        return {
            easy: ['passive', 'defensive', 'random'],
            normal: ['aggressive', 'strategic', 'adaptive'],
            hard: ['ruthless', 'predictive', 'coordinated'],
            nightmare: ['psychotic', 'unpredictable', 'overwhelming']
        }[this.difficulty] || ['normal'];
    }
    
    generatePersonality() {
        return {
            aggression: Math.random() * 0.8 + 0.2, // 0.2 ~ 1.0
            caution: Math.random() * 0.6 + 0.2,    // 0.2 ~ 0.8
            creativity: Math.random() * 0.7 + 0.3, // 0.3 ~ 1.0
            adaptability: Math.random() * 0.8 + 0.2, // 0.2 ~ 1.0
            patience: Math.random() * 0.6 + 0.4     // 0.4 ~ 1.0
        };
    }
    
    createBehaviorTree() {
        return {
            root: {
                type: 'selector',
                children: [
                    {
                        type: 'sequence',
                        name: 'emergency_response',
                        children: [
                            { type: 'condition', name: 'is_critical_health' },
                            { type: 'action', name: 'retreat_to_safety' }
                        ]
                    },
                    {
                        type: 'sequence',
                        name: 'strategic_planning',
                        children: [
                            { type: 'condition', name: 'has_advantage' },
                            { type: 'action', name: 'execute_aggressive_strategy' }
                        ]
                    },
                    {
                        type: 'sequence',
                        name: 'defensive_maneuver',
                        children: [
                            { type: 'condition', name: 'is_at_disadvantage' },
                            { type: 'action', name: 'execute_defensive_strategy' }
                        ]
                    },
                    {
                        type: 'action',
                        name: 'explore_and_gather'
                    }
                ]
            }
        };
    }
    
    makeDecision(gameState) {
        const now = Date.now();
        if (now - this.lastActionTime < this.actionCooldown) {
            return this.getLastDecision();
        }
        
        // AI ë¶„ì„ ë° ì˜ì‚¬ê²°ì •
        const analysis = this.analyzeGameState(gameState);
        const decision = this.evaluateOptions(analysis);
        
        // ê²°ì • ê¸°ë¡
        this.recordDecision(decision, analysis);
        
        // í–‰ë™ ì‹¤í–‰
        this.executeDecision(decision);
        
        this.lastActionTime = now;
        return decision;
    }
    
    analyzeGameState(gameState) {
        const analysis = {
            threatLevel: this.calculateThreatLevel(gameState),
            opportunityLevel: this.calculateOpportunityLevel(gameState),
            resourceStatus: this.analyzeResourceStatus(gameState),
            playerBehavior: this.analyzePlayerBehavior(gameState),
            environmentalFactors: this.analyzeEnvironmentalFactors(gameState)
        };
        
        // ë©”ëª¨ë¦¬ì— ë¶„ì„ ê²°ê³¼ ì €ì¥
        this.memory.set('lastAnalysis', {
            timestamp: Date.now(),
            data: analysis
        });
        
        return analysis;
    }
    
    calculateThreatLevel(gameState) {
        let threatLevel = 0;
        
        // í”Œë ˆì´ì–´ ì „íˆ¬ë ¥ í‰ê°€
        if (gameState.player) {
            threatLevel += gameState.player.combatPower * 0.3;
            threatLevel += gameState.player.level * 0.2;
        }
        
        // í”Œë ˆì´ì–´ ìì› ìƒíƒœ í‰ê°€
        if (gameState.playerResources) {
            threatLevel += gameState.playerResources.minerals * 0.001;
            threatLevel += gameState.playerResources.gas * 0.002;
        }
        
        // í”Œë ˆì´ì–´ ê±´ë¬¼ ìƒíƒœ í‰ê°€
        if (gameState.playerBuildings) {
            threatLevel += gameState.playerBuildings.length * 0.1;
        }
        
        return Math.min(threatLevel, 1.0);
    }
    
    calculateOpportunityLevel(gameState) {
        let opportunityLevel = 0;
        
        // í”Œë ˆì´ì–´ ì·¨ì•½ì  í‰ê°€
        if (gameState.player) {
            if (gameState.player.health < 50) opportunityLevel += 0.3;
            if (gameState.player.energy < 30) opportunityLevel += 0.2;
        }
        
        // ìì› ë…¸ì¶œë„ í‰ê°€
        if (gameState.playerResources) {
            if (gameState.playerResources.minerals > 1000) opportunityLevel += 0.2;
            if (gameState.playerResources.gas > 500) opportunityLevel += 0.2;
        }
        
        // ë°©ì–´ ìƒíƒœ í‰ê°€
        if (gameState.playerDefenses) {
            if (gameState.playerDefenses.length < 3) opportunityLevel += 0.3;
        }
        
        return Math.min(opportunityLevel, 1.0);
    }
    
    evaluateOptions(analysis) {
        const options = [];
        
        // ê³µê²© ì˜µì…˜
        if (analysis.opportunityLevel > 0.6 && analysis.threatLevel < 0.7) {
            options.push({
                action: 'attack',
                priority: analysis.opportunityLevel * 0.8,
                risk: analysis.threatLevel * 0.6
            });
        }
        
        // ë°©ì–´ ì˜µì…˜
        if (analysis.threatLevel > 0.6) {
            options.push({
                action: 'defend',
                priority: analysis.threatLevel * 0.9,
                risk: 0.1
            });
        }
        
        // ìì› ìˆ˜ì§‘ ì˜µì…˜
        if (analysis.resourceStatus.needResources) {
            options.push({
                action: 'gather_resources',
                priority: 0.5,
                risk: 0.2
            });
        }
        
        // ì „ëµì  í›„í‡´ ì˜µì…˜
        if (analysis.threatLevel > 0.8) {
            options.push({
                action: 'retreat',
                priority: analysis.threatLevel * 0.7,
                risk: 0.3
            });
        }
        
        // ì˜µì…˜ í‰ê°€ ë° ìµœì  ì„ íƒ
        return this.selectBestOption(options);
    }
    
    selectBestOption(options) {
        if (options.length === 0) {
            return { action: 'explore', priority: 0.3, risk: 0.1 };
        }
        
        // ìš°ì„ ìˆœìœ„ì™€ ìœ„í—˜ë„ë¥¼ ê³ ë ¤í•œ ì ìˆ˜ ê³„ì‚°
        const scoredOptions = options.map(option => ({
            ...option,
            score: option.priority - (option.risk * this.personality.caution)
        }));
        
        // ì ìˆ˜ ìˆœìœ¼ë¡œ ì •ë ¬
        scoredOptions.sort((a, b) => b.score - a.score);
        
        // ì„±ê²©ì— ë”°ë¥¸ ì„ íƒ í™•ë¥  ì¡°ì •
        const topOption = scoredOptions[0];
        const selectionProbability = this.calculateSelectionProbability(topOption, scoredOptions);
        
        if (Math.random() < selectionProbability) {
            return topOption;
        } else {
            // ë‘ ë²ˆì§¸ ì˜µì…˜ ì„ íƒ
            return scoredOptions[1] || topOption;
        }
    }
    
    calculateSelectionProbability(topOption, allOptions) {
        let baseProbability = 0.7;
        
        // ì„±ê²©ì— ë”°ë¥¸ ì¡°ì •
        baseProbability += this.personality.creativity * 0.1;
        baseProbability -= this.personality.caution * 0.1;
        
        // ë‚œì´ë„ì— ë”°ë¥¸ ì¡°ì •
        if (this.difficulty === 'hard') baseProbability -= 0.1;
        if (this.difficulty === 'nightmare') baseProbability -= 0.2;
        
        return Math.max(0.3, Math.min(0.9, baseProbability));
    }
    
    executeDecision(decision) {
        switch (decision.action) {
            case 'attack':
                this.executeAttackStrategy(decision);
                break;
            case 'defend':
                this.executeDefenseStrategy(decision);
                break;
            case 'gather_resources':
                this.executeResourceGatheringStrategy(decision);
                break;
            case 'retreat':
                this.executeRetreatStrategy(decision);
                break;
            case 'explore':
                this.executeExplorationStrategy(decision);
                break;
        }
    }
    
    executeAttackStrategy(decision) {
        // ê³µê²© ì „ëµ ì‹¤í–‰
        const attackPlan = this.createAttackPlan(decision);
        
        // ê³µê²© ì‹¤í–‰
        this.executeAttackPlan(attackPlan);
        
        // ê²°ê³¼ ê¸°ë¡
        this.recordActionResult('attack', attackPlan);
    }
    
    createAttackPlan(decision) {
        return {
            type: 'attack',
            target: this.selectAttackTarget(),
            units: this.selectAttackUnits(),
            formation: this.determineAttackFormation(),
            timing: this.calculateOptimalAttackTiming(),
            fallback: this.prepareFallbackPlan()
        };
    }
    
    selectAttackTarget() {
        // ê³µê²© ëŒ€ìƒ ì„ íƒ ë¡œì§
        const targets = this.getAvailableTargets();
        
        if (targets.length === 0) return null;
        
        // ìœ„í—˜ë„ì™€ ê°€ì¹˜ë¥¼ ê³ ë ¤í•œ ëŒ€ìƒ ì„ íƒ
        const scoredTargets = targets.map(target => ({
            ...target,
            score: target.value - (target.risk * this.personality.caution)
        }));
        
        scoredTargets.sort((a, b) => b.score - a.score);
        return scoredTargets[0];
    }
    
    executeAttackPlan(attackPlan) {
        // ê³µê²© ê³„íš ì‹¤í–‰
        console.log(`Executing attack plan: ${JSON.stringify(attackPlan)}`);
        
        // ì‹¤ì œ ê²Œì„ ë¡œì§ì— ì—°ê²°
        if (window.gameInstance && window.gameInstance.executeAIAction) {
            window.gameInstance.executeAIAction('attack', attackPlan);
        }
    }
    
    recordActionResult(action, result) {
        this.decisionHistory.push({
            timestamp: Date.now(),
            action: action,
            result: result,
            success: this.evaluateActionSuccess(action, result)
        });
        
        // ì„±ê³µë¥ ì— ë”°ë¥¸ ì ì‘
        this.adaptBehavior(action, result);
    }
    
    evaluateActionSuccess(action, result) {
        // ì•¡ì…˜ ì„±ê³µ ì—¬ë¶€ í‰ê°€
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ê²Œì„ ìƒíƒœ ë³€í™”ë¥¼ í™•ì¸
        return Math.random() > 0.3; // ì„ì‹œ êµ¬í˜„
    }
    
    adaptBehavior(action, result) {
        // í–‰ë™ ê²°ê³¼ì— ë”°ë¥¸ AI í–‰ë™ íŒ¨í„´ ì ì‘
        if (result.success) {
            this.adaptationLevel += 0.1;
        } else {
            this.adaptationLevel -= 0.05;
        }
        
        this.adaptationLevel = Math.max(0, Math.min(1, this.adaptationLevel));
        
        // ì„±ê²© íŠ¹ì„± ì¡°ì •
        this.adjustPersonality(action, result);
    }
    
    adjustPersonality(action, result) {
        if (action === 'attack') {
            if (result.success) {
                this.personality.aggression += 0.05;
                this.personality.caution -= 0.03;
            } else {
                this.personality.aggression -= 0.03;
                this.personality.caution += 0.05;
            }
        }
        
        // ì„±ê²© íŠ¹ì„± ë²”ìœ„ ì œí•œ
        for (const trait in this.personality) {
            this.personality[trait] = Math.max(0.1, Math.min(1.0, this.personality[trait]));
        }
    }
    
    getActionCooldown() {
        // ë‚œì´ë„ì™€ ì„±ê²©ì— ë”°ë¥¸ ì•¡ì…˜ ì¿¨ë‹¤ìš´
        let baseCooldown = 1000; // 1ì´ˆ
        
        if (this.difficulty === 'easy') baseCooldown *= 1.5;
        if (this.difficulty === 'hard') baseCooldown *= 0.7;
        if (this.difficulty === 'nightmare') baseCooldown *= 0.5;
        
        // ì„±ê²©ì— ë”°ë¥¸ ì¡°ì •
        baseCooldown *= (1.5 - this.personality.aggression);
        
        return Math.max(200, Math.min(3000, baseCooldown));
    }
    
    getLastDecision() {
        if (this.decisionHistory.length > 0) {
            return this.decisionHistory[this.decisionHistory.length - 1];
        }
        return { action: 'wait', priority: 0.1, risk: 0.1 };
    }
    
    // AI ìƒíƒœ ì •ë³´ ë°˜í™˜
    getAIStatus() {
        return {
            difficulty: this.difficulty,
            personality: this.personality,
            adaptationLevel: this.adaptationLevel,
            currentPattern: this.behaviorPatterns[this.currentPattern],
            lastActionTime: this.lastActionTime,
            decisionCount: this.decisionHistory.length,
            successRate: this.calculateSuccessRate()
        };
    }
    
    calculateSuccessRate() {
        if (this.decisionHistory.length === 0) return 0;
        
        const successfulActions = this.decisionHistory.filter(decision => decision.success);
        return successfulActions.length / this.decisionHistory.length;
    }
}
```

---

### ğŸ”§ í”„ë¡œì íŠ¸ ì „ì²´ ê°œì„  ì œì•ˆ (ì‹¬í™”)

#### 1. ğŸ“± ê³ ê¸‰ ëª¨ë°”ì¼ ì•± ì‹œìŠ¤í…œ (ê³ ë„í™”)
**ìš°ì„ ìˆœìœ„**: ë†’ìŒ ğŸ”´
**ì˜ˆìƒ ê°œë°œ ì‹œê°„**: 8-12ì£¼
**ê¸°ìˆ ì  ë³µì¡ë„**: ë§¤ìš° ë†’ìŒ

```javascript
// ê³ ê¸‰ ëª¨ë°”ì¼ ì•± ë§¤ë‹ˆì €
class AdvancedMobileAppManager {
    constructor() {
        this.platform = this.detectPlatform();
        this.capabilities = this.detectCapabilities();
        this.offlineMode = false;
        this.syncQueue = [];
        
        this.initMobileFeatures();
    }
    
    detectPlatform() {
        if (navigator.userAgent.includes('Android')) return 'android';
        if (navigator.userAgent.includes('iPhone') || navigator.userAgent.includes('iPad')) return 'ios';
        if (navigator.userAgent.includes('Windows Phone')) return 'windows';
        return 'web';
    }
    
    detectCapabilities() {
        return {
            touch: 'ontouchstart' in window,
            vibration: 'vibrate' in navigator,
            geolocation: 'geolocation' in navigator,
            camera: 'getUserMedia' in navigator,
            pushNotifications: 'serviceWorker' in navigator && 'PushManager' in window,
            offline: 'serviceWorker' in navigator,
            webGL: !!window.WebGLRenderingContext,
            webAudio: !!window.AudioContext || !!window.webkitAudioContext
        };
    }
    
    initMobileFeatures() {
        this.initServiceWorker();
        this.initTouchGestures();
        this.initOfflineSupport();
        this.initPushNotifications();
        this.initProgressiveWebApp();
    }
    
    initServiceWorker() {
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
                .then(registration => {
                    console.log('Service Worker registered:', registration);
                    this.setupServiceWorkerEvents(registration);
                })
                .catch(error => {
                    console.error('Service Worker registration failed:', error);
                });
        }
    }
    
    setupServiceWorkerEvents(registration) {
        registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                    this.showUpdateNotification();
                }
            });
        });
    }
    
    initTouchGestures() {
        if (!this.capabilities.touch) return;
        
        // ìŠ¤ì™€ì´í”„ ì œìŠ¤ì²˜
        this.initSwipeGestures();
        
        // í•€ì¹˜ ì¤Œ ì œìŠ¤ì²˜
        this.initPinchGestures();
        
        // ë¡± í”„ë ˆìŠ¤ ì œìŠ¤ì²˜
        this.initLongPressGestures();
        
        // ë”ë¸” íƒ­ ì œìŠ¤ì²˜
        this.initDoubleTapGestures();
    }
    
    initSwipeGestures() {
        let startX, startY, endX, endY;
        const minSwipeDistance = 50;
        
        document.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
        });
        
        document.addEventListener('touchend', (e) => {
            endX = e.changedTouches[0].clientX;
            endY = e.changedTouches[0].clientY;
            
            const deltaX = endX - startX;
            const deltaY = endY - startY;
            
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (Math.abs(deltaX) > minSwipeDistance) {
                    if (deltaX > 0) {
                        this.handleSwipe('right');
                    } else {
                        this.handleSwipe('left');
                    }
                }
            } else {
                if (Math.abs(deltaY) > minSwipeDistance) {
                    if (deltaY > 0) {
                        this.handleSwipe('down');
                    } else {
                        this.handleSwipe('up');
                    }
                }
            }
        });
    }
    
    handleSwipe(direction) {
        console.log(`Swipe detected: ${direction}`);
        
        // ê²Œì„ë³„ ìŠ¤ì™€ì´í”„ ì•¡ì…˜ ì²˜ë¦¬
        switch (direction) {
            case 'left':
                this.executeSwipeAction('left');
                break;
            case 'right':
                this.executeSwipeAction('right');
                break;
            case 'up':
                this.executeSwipeAction('up');
                break;
            case 'down':
                this.executeSwipeAction('down');
                break;
        }
    }
    
    executeSwipeAction(direction) {
        // í˜„ì¬ í™œì„±í™”ëœ ê²Œì„ì— ìŠ¤ì™€ì´í”„ ì•¡ì…˜ ì „ë‹¬
        if (window.currentGame) {
            window.currentGame.handleSwipe(direction);
        }
    }
    
    initOfflineSupport() {
        if (!this.capabilities.offline) return;
        
        // ì˜¤í”„ë¼ì¸ ëª¨ë“œ ê°ì§€
        window.addEventListener('online', () => {
            this.offlineMode = false;
            this.syncOfflineData();
            this.showNotification('ì˜¨ë¼ì¸ ëª¨ë“œë¡œ ì „í™˜ë˜ì—ˆìŠµë‹ˆë‹¤.');
        });
        
        window.addEventListener('offline', () => {
            this.offlineMode = true;
            this.showNotification('ì˜¤í”„ë¼ì¸ ëª¨ë“œë¡œ ì „í™˜ë˜ì—ˆìŠµë‹ˆë‹¤.');
        });
    }
    
    initPushNotifications() {
        if (!this.capabilities.pushNotifications) return;
        
        this.requestNotificationPermission();
    }
    
    async requestNotificationPermission() {
        try {
            const permission = await Notification.requestPermission();
            if (permission === 'granted') {
                this.subscribeToPushNotifications();
            }
        } catch (error) {
            console.error('Notification permission request failed:', error);
        }
    }
    
    async subscribeToPushNotifications() {
        try {
            const registration = await navigator.serviceWorker.ready;
            const subscription = await registration.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: this.urlBase64ToUint8Array('YOUR_VAPID_PUBLIC_KEY')
            });
            
            // ì„œë²„ì— êµ¬ë… ì •ë³´ ì „ì†¡
            await this.sendSubscriptionToServer(subscription);
            
        } catch (error) {
            console.error('Push notification subscription failed:', error);
        }
    }
    
    initProgressiveWebApp() {
        // PWA ì„¤ì¹˜ í”„ë¡¬í”„íŠ¸
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            this.showInstallPrompt();
        });
        
        // ì•± ì„¤ì¹˜ ì™„ë£Œ ì´ë²¤íŠ¸
        window.addEventListener('appinstalled', () => {
            this.hideInstallPrompt();
            this.trackAppInstallation();
        });
    }
    
    showInstallPrompt() {
        const installButton = document.getElementById('install-button');
        if (installButton) {
            installButton.style.display = 'block';
            installButton.addEventListener('click', () => {
                this.installApp();
            });
        }
    }
    
    async installApp() {
        if (this.deferredPrompt) {
            this.deferredPrompt.prompt();
            const { outcome } = await this.deferredPrompt.userChoice;
            
            if (outcome === 'accepted') {
                console.log('App installed successfully');
            } else {
                console.log('App installation declined');
            }
            
            this.deferredPrompt = null;
        }
    }
    
    // ëª¨ë°”ì¼ ìµœì í™” ê¸°ëŠ¥ë“¤
    optimizeForMobile() {
        this.adjustTouchTargets();
        this.optimizePerformance();
        this.enableHapticFeedback();
    }
    
    adjustTouchTargets() {
        // í„°ì¹˜ íƒ€ê²Ÿ í¬ê¸° ì¡°ì • (ìµœì†Œ 44x44px)
        const touchTargets = document.querySelectorAll('[data-touch-target]');
        touchTargets.forEach(target => {
            target.style.minWidth = '44px';
            target.style.minHeight = '44px';
        });
    }
    
    optimizePerformance() {
        // ëª¨ë°”ì¼ ì„±ëŠ¥ ìµœì í™”
        if (this.platform === 'android' || this.platform === 'ios') {
            // ì• ë‹ˆë©”ì´ì…˜ í”„ë ˆì„ ë ˆì´íŠ¸ ì¡°ì •
            this.adjustAnimationFrameRate();
            
            // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™”
            this.optimizeMemoryUsage();
        }
    }
    
    enableHapticFeedback() {
        if (this.capabilities.vibration) {
            // í–…í‹± í”¼ë“œë°± í™œì„±í™”
            this.hapticPatterns = {
                success: [100],
                error: [200, 100, 200],
                warning: [100, 100, 100],
                selection: [50]
            };
        }
    }
    
    triggerHapticFeedback(pattern) {
        if (this.capabilities.vibration && this.hapticPatterns[pattern]) {
            navigator.vibrate(this.hapticPatterns[pattern]);
        }
    }
    
    // ì˜¤í”„ë¼ì¸ ë°ì´í„° ë™ê¸°í™”
    async syncOfflineData() {
        if (this.syncQueue.length === 0) return;
        
        console.log(`Syncing ${this.syncQueue.length} offline actions...`);
        
        for (const action of this.syncQueue) {
            try {
                await this.syncAction(action);
                this.syncQueue = this.syncQueue.filter(a => a !== action);
            } catch (error) {
                console.error('Sync failed for action:', action, error);
            }
        }
        
        this.showNotification('ì˜¤í”„ë¼ì¸ ë°ì´í„° ë™ê¸°í™”ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
    }
    
    async syncAction(action) {
        // ì„œë²„ì— ì˜¤í”„ë¼ì¸ ì•¡ì…˜ ë™ê¸°í™”
        const response = await fetch('/api/sync', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(action)
        });
        
        if (!response.ok) {
            throw new Error('Sync failed');
        }
        
        return response.json();
    }
    
    // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
    urlBase64ToUint8Array(base64String) {
        const padding = '='.repeat((4 - base64String.length % 4) % 4);
        const base64 = (base64String + padding)
            .replace(/-/g, '+')
            .replace(/_/g, '/');
        
        const rawData = window.atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        
        for (let i = 0; i < rawData.length; ++i) {
            outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
    }
    
    showNotification(message) {
        if (this.capabilities.pushNotifications && Notification.permission === 'granted') {
            new Notification('ê²Œì„ ì•Œë¦¼', {
                body: message,
                icon: '/icon-192x192.png',
                badge: '/badge-72x72.png'
            });
        } else {
            // í´ë°±: í† ìŠ¤íŠ¸ ë©”ì‹œì§€
            this.showToastMessage(message);
        }
    }
    
    showToastMessage(message) {
        const toast = document.createElement('div');
        toast.className = 'toast-message';
        toast.textContent = message;
        
        document.body.appendChild(toast);
        
        setTimeout(() => {
            toast.remove();
        }, 3000);
    }
    
    // ëª¨ë°”ì¼ ì•± ìƒíƒœ ì •ë³´
    getMobileAppStatus() {
        return {
            platform: this.platform,
            capabilities: this.capabilities,
            offlineMode: this.offlineMode,
            syncQueueLength: this.syncQueue.length,
            notificationPermission: Notification.permission,
            serviceWorkerStatus: 'serviceWorker' in navigator ? 'registered' : 'not_supported'
        };
    }
}
```

---

### ğŸ“Š ì—…ë°ì´íŠ¸ëœ ìš°ì„ ìˆœìœ„ ë§¤íŠ¸ë¦­ìŠ¤ (2025-08-15 23:40)

| ê¸°ëŠ¥ | ì‚¬ìš©ì ê°€ì¹˜ | ê°œë°œ ë³µì¡ë„ | ê¸°ìˆ ì  ì„±ìˆ™ë„ | ìš°ì„ ìˆœìœ„ | ì˜ˆìƒ ê°œë°œ ì‹œê°„ |
|------|-------------|-------------|---------------|----------|----------------|
| **í…ŒíŠ¸ë¦­ìŠ¤ ê³ ê¸‰ ì¸ì¦ ì‹œìŠ¤í…œ** | ë†’ìŒ | ë†’ìŒ | ë†’ìŒ | ğŸ”´ ìµœê³  | 3-4ì£¼ |
| **í…ŒíŠ¸ë¦­ìŠ¤ ê³ ê¸‰ ì‚¬ìš´ë“œ ì‹œìŠ¤í…œ** | ë†’ìŒ | ì¤‘ê°„ | ë†’ìŒ | ğŸ”´ ìµœê³  | 1-2ì£¼ |
| **í…ŒíŠ¸ë¦­ìŠ¤ ê³ ê¸‰ ë¦¬ë”ë³´ë“œ** | ì¤‘ê°„ | ì¤‘ê°„ | ë†’ìŒ | ğŸŸ¡ ë†’ìŒ | 2-3ì£¼ |
| **í…ŒíŠ¸ë¦­ìŠ¤ ê³ ê¸‰ í…Œë§ˆ ì‹œìŠ¤í…œ** | ì¤‘ê°„ | ì¤‘ê°„ | ë†’ìŒ | ğŸŸ¡ ë†’ìŒ | 2-3ì£¼ |
| **ìŠ¤íƒ€í¬ë˜í”„íŠ¸ RPG ê³ ê¸‰ ë©€í‹°í”Œë ˆì´ì–´** | ë†’ìŒ | ë†’ìŒ | ì¤‘ê°„ | ğŸŸ¡ ë†’ìŒ | 4-6ì£¼ |
| **ìŠ¤íƒ€í¬ë˜í”„íŠ¸ RPG ê³ ê¸‰ í€˜ìŠ¤íŠ¸** | ì¤‘ê°„ | ë†’ìŒ | ì¤‘ê°„ | ğŸŸ¢ ì¤‘ê°„ | 6-8ì£¼ |
| **ìŠ¤íƒ€í¬ë˜í”„íŠ¸ RPG ê³ ê¸‰ AI ì ** | ì¤‘ê°„ | ë†’ìŒ | ì¤‘ê°„ | ğŸŸ¢ ì¤‘ê°„ | 4-5ì£¼ |
| **ê³ ê¸‰ ëª¨ë°”ì¼ ì•± ì‹œìŠ¤í…œ** | ë†’ìŒ | ë§¤ìš° ë†’ìŒ | ì¤‘ê°„ | ğŸŸ¢ ì¤‘ê°„ | 8-12ì£¼ |

---

### ğŸ¯ AIì˜ ì„ì˜íŒë‹¨ ë‚´ìš© ë° ìƒê° (ìµœì¢… ì—…ë°ì´íŠ¸)

#### ğŸ”¬ ê¸°ìˆ ì  ë¶„ì„ ë° ì œì•ˆ (ì‹¬í™”)

**ì„±ëŠ¥ ìµœì í™” ì˜ì—­ (ê³ ë„í™”):**
- **ë©”ëª¨ë¦¬ ê´€ë¦¬**: ê²Œì„ ì˜¤ë¸Œì íŠ¸ í’€ë§ ì‹œìŠ¤í…œ, ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ìµœì í™”
- **ë Œë”ë§ ìµœì í™”**: WebGL ê°€ì†, ì˜¤í”„ìŠ¤í¬ë¦° ìº”ë²„ìŠ¤, í”„ë ˆì„ ë ˆì´íŠ¸ ë™ì  ì¡°ì •
- **ë„¤íŠ¸ì›Œí¬ ìµœì í™”**: WebSocket ì—°ê²° í’€ë§, ì¬ì—°ê²° ë¡œì§, ë°ì´í„° ì••ì¶•
- **ë¡œë”© ìµœì í™”**: ì§€ì—° ë¡œë”©, í”„ë¦¬ë¡œë”©, ì—ì…‹ ë²ˆë“¤ë§

**ë³´ì•ˆ ê°•í™” ì˜ì—­ (ê³ ë„í™”):**
- **ì‚¬ìš©ì ì¸ì¦**: JWT í† í° ê¸°ë°˜ ë³´ì•ˆ ì‹œìŠ¤í…œ, OAuth 2.0 í†µí•©
- **ë°ì´í„° ë³´í˜¸**: í´ë¼ì´ì–¸íŠ¸-ì„œë²„ ê°„ ì•”í˜¸í™” í†µì‹ , HTTPS ê°•ì œ
- **ì…ë ¥ ê²€ì¦**: XSS ë° CSRF ê³µê²© ë°©ì§€, SQL ì¸ì ì…˜ ë°©ì§€
- **ì„¸ì…˜ ê´€ë¦¬**: ì•ˆì „í•œ ì„¸ì…˜ ìƒì„± ë° ê´€ë¦¬, ìë™ ë¡œê·¸ì•„ì›ƒ

**ì ‘ê·¼ì„± ê°œì„  ì˜ì—­ (ê³ ë„í™”):**
- **ìŠ¤í¬ë¦° ë¦¬ë” ì§€ì›**: ARIA ë¼ë²¨, í‚¤ë³´ë“œ ë„¤ë¹„ê²Œì´ì…˜, í¬ì»¤ìŠ¤ ê´€ë¦¬
- **ìƒ‰ë§¹ ì§€ì›**: ë‹¤ì–‘í•œ ìƒ‰ìƒ í…Œë§ˆ, ëŒ€ë¹„ ì¡°ì •, íŒ¨í„´ êµ¬ë¶„
- **ëª¨ë°”ì¼ ìµœì í™”**: í„°ì¹˜ ì œìŠ¤ì²˜, ë°˜ì‘í˜• ë””ìì¸, ì„±ëŠ¥ ìµœì í™”
- **êµ­ì œí™”**: ë‹¤êµ­ì–´ ì§€ì›, ì§€ì—­ë³„ ì„¤ì •, ë¬¸í™”ì  ê³ ë ¤ì‚¬í•­

#### ğŸš€ ë‹¤ìŒ ë‹¨ê³„ ê³„íš (ìµœì¢…)

**1-2ê°œì›” (ë‹¨ê¸°) - ìµœê³  ìš°ì„ ìˆœìœ„:**
- í…ŒíŠ¸ë¦­ìŠ¤ ê³ ê¸‰ ì¸ì¦ ì‹œìŠ¤í…œ êµ¬í˜„
- í…ŒíŠ¸ë¦­ìŠ¤ ê³ ê¸‰ ì‚¬ìš´ë“œ ì‹œìŠ¤í…œ í†µí•©
- í”„ë¡œì íŠ¸ ì „ì²´ ì„±ëŠ¥ ìµœì í™” ë° ëª¨ë°”ì¼ ì§€ì› ê°•í™”
- ìë™í™”ëœ í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œ êµ¬ì¶•

**3-6ê°œì›” (ì¤‘ê¸°) - ë†’ì€ ìš°ì„ ìˆœìœ„:**
- í…ŒíŠ¸ë¦­ìŠ¤ ê³ ê¸‰ ë¦¬ë”ë³´ë“œ ë° í…Œë§ˆ ì‹œìŠ¤í…œ
- ìŠ¤íƒ€í¬ë˜í”„íŠ¸ RPG ê³ ê¸‰ ë©€í‹°í”Œë ˆì´ì–´ ì‹œìŠ¤í…œ
- ì „íˆ¬ ì‹œìŠ¤í…œ ë° í€˜ìŠ¤íŠ¸ ì‹œìŠ¤í…œ êµ¬í˜„
- CI/CD íŒŒì´í”„ë¼ì¸ êµ¬ì¶•

**6ê°œì›” ì´ìƒ (ì¥ê¸°) - ì¤‘ê°„ ìš°ì„ ìˆœìœ„:**
- ê³ ê¸‰ ëª¨ë°”ì¼ ì•± ì‹œìŠ¤í…œ ê°œë°œ
- AI ê¸°ë°˜ ê²Œì„ ì¶”ì²œ ì‹œìŠ¤í…œ
- í´ë¼ìš°ë“œ ê¸°ë°˜ ê²Œì„ í”Œë«í¼ êµ¬ì¶•
- ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë°˜ ê²Œì„ ë°¸ëŸ°ì‹±

---

### ğŸ“ˆ ìµœì¢… ì„±ê³¼ ì§€í‘œ ë° ì˜ˆì¸¡

**í˜„ì¬ ìƒíƒœ (2025-08-15 23:40):**
- **ì „ì²´ ì§„í–‰ë¥ **: 90% â†’ 92% (ë¬¸ì„œí™” ë° ê³„íš ìˆ˜ë¦½ ê³ ë„í™”)
- **í…ŒíŠ¸ë¦­ìŠ¤ ê²Œì„**: 95% â†’ 96% (ê³ ê¸‰ ì‹œìŠ¤í…œ ì„¤ê³„ ì™„ë£Œ)
- **ìŠ¤íƒ€í¬ë˜í”„íŠ¸ RPG**: 85% â†’ 87% (ê³ ê¸‰ ì‹œìŠ¤í…œ ì„¤ê³„ ì™„ë£Œ)
- **í†µí•© ì‹œìŠ¤í…œ**: 90% â†’ 93% (ê³ ê¸‰ ì‹œìŠ¤í…œ ì„¤ê³„ ì™„ë£Œ)

**í–¥í›„ 6ê°œì›” ì˜ˆì¸¡:**
- **ì „ì²´ ì§„í–‰ë¥ **: 92% â†’ 98% (ê³ ê¸‰ ì‹œìŠ¤í…œ êµ¬í˜„ ì™„ë£Œ)
- **í…ŒíŠ¸ë¦­ìŠ¤ ê²Œì„**: 96% â†’ 99% (ê³ ê¸‰ ì‹œìŠ¤í…œ êµ¬í˜„ ì™„ë£Œ)
- **ìŠ¤íƒ€í¬ë˜í”„íŠ¸ RPG**: 87% â†’ 95% (ê³ ê¸‰ ì‹œìŠ¤í…œ êµ¬í˜„ ì™„ë£Œ)
- **í†µí•© ì‹œìŠ¤í…œ**: 93% â†’ 98% (ê³ ê¸‰ ì‹œìŠ¤í…œ êµ¬í˜„ ì™„ë£Œ)

---

**AI ì–´ì‹œìŠ¤í„´íŠ¸**: Claude Sonnet 4  
**ìµœì¢… ì—…ë°ì´íŠ¸**: 2025ë…„ 8ì›” 16ì¼ 00:04  
**í”„ë¡œì íŠ¸ ìƒíƒœ**: ê³ ê¸‰ ì‚¬ìš´ë“œ ì‹œìŠ¤í…œ êµ¬í˜„ ì™„ë£Œ, í…ŒíŠ¸ë¦­ìŠ¤ ê²Œì„ í†µí•© ì™„ë£Œ ğŸµğŸ®
